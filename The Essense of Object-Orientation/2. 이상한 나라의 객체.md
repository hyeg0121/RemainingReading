
## 객체, 그리고 소프트웨어 나라

- 객체란 식별 가능한 개체 또는 사물이다
- 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다
- 객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다
- 소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다

상태
- 상태가 필요한 이유
	- 과거의 모든 행동 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다
	- 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다
	- 상태는 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념이다
- 상태와 프로퍼티
	- 숫자, 문자열, 양, 속도, 시간, 날짜, 참 / 거짓 같은 단순한 값들은 객체가 아니다
		- 그 자체로 독립적인 의미를 가지는 것이 아닌 다른 객체의 특성을 표현한다
		- 즉, 객체의 상태를 표현하는 데 사용된다
	- 때로는 객체를 사용해 객체의 상태를 나타내기도 한다
	- 결론적으로 모든 객체의 상태는 단순한 값과 객체의 조합으로 표현될 수 있다
	- 이때 객체의 상태를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 한다
- 상태의 정의
	- 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현한다
	- 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다
	- 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다

행동
- 상태와 행동
	- 상태와 행동 사이에는 다음과 같은 관계가 있다
		- 객체의 행동은 상태에 영향을 받는다
		- 객체의 행동은 상태를 변화시킨다
	- 상태라는 개념을 이용해 행동을 다음의 두 가지 관점에서 서술할 수 있다
		- 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
		- 상호작용이 어떻게 현재의 상태를 변경시키는가
- 협력과 행동
	- 객체의 행동은 두 가지 관점의 부수효과를 명확하게 서술해야 한다
		- 객체 자신의 상태 변경
		- 행동 내에서 협력하는 다른 객체에 대한 메시지 전송
- 행동의 정의
	- 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다
	- 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다
	- 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이어야 한다
- 상태 캡슐화
	- 객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다
	- 객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다
	- 상태를 외부에 노출시키지 않고 행동을 경계로 캡슐화하는 것은 결과적으로 객체의 자율성을 높인다
		- 자율성이 높아질 수록 객체의 지능도 높아진다
		- 협력에 참여하는 객체들의 지능이 높아질수록 협력은 유연하고 간결해진다

 식별자
 - 객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 것을 의미한다 → 이 프로퍼티를 식별자라고 한다
 - 값(value)는 숫자, 문자열, 날짜, 시간 등과 같이 정적인 양을 모델링한다
	 - 흔히 값의 상태는 변하지 않기 때문에 불변 상태(immutable state)를 가진다고 말한다
 - 값이 같은지 여부는 상태가 같은지를 이용해 판단한다
	 - 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 동등성(equality)라고 한다
- 객체는 가변상태(muatable state)를 가진다
	- 타입이 같은 구 객체의 상태가 완전히 똑같더라도 두 객체는 독립적인 별개의 객체로 다루어야 한다
	- 두 객체의 상태가 다르더라도 식별자가 같다면 두 객체를 같은 객체로 판단할 수 있다
	- 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 동일성(identical)이라 한다

```
<식별자> 요약
- 식별자란 어떤 객체를 다른 객체와 구분하는 데 사용하는 객체의 프로퍼티다. 
- 값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 구분해야 한다. 
- 객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.
```

```
<객체, 그리고 소프트웨어 나라> 요약
- 객체는 상태를 가지며 상태는 변경 가능하다
- 객체의 상태를 변경시키는 것은 객체의 행동이다
	- 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다
	- 행동의 순서가 실행 결과에 영향을 미친다
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능하다
```

## 기계로서의 객체

- 일반적으로 객체의 상태를 조회하는 작업을 쿼리(query)라고 하고, 객체의 상태를 변경하는 작업을 명령(command)라고 한다
	- 객체가 외부에 제공하는 행동의 대부분은 쿼리와 명령으로 구성된다
- 기계은유에서 객체에 접근할 수 있는 유일한 방법은 객체가 제공하는 행동뿐이라는 점을 강조한다
- 기계은유에서 객체 기계가 제공하는 버튼을 통해서만 상태에 접근할 수 있다는 점은 객체의 캡슐화를 강조한다

## 행동이 상태를 결정한다

- 상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 준다
	- 상태를 먼저 결정할 경우 캡슐화가 저해된다
		- 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되버릴 확률이 높아진다
	- 객체를 협력자가 아닌 고립된 섬으로 만든다
		- 객체가 필요한 이유는 애플리케이션의 문맥 내에서 다른 객체와 협력하기 위해서다
		- 상태를 먼저 고려하는 방식은 협력이라는 문맥에서 멀리 벗어난 채 객체를 설계하게 함으로써 자연스럽게 협력에 적합하지 못한 객체를 만들게 된다
	- 객체의 재사용성이 저하된다
		- 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나온다
		- 상태에 초점을 맞춘 객체는 다양한 협력에 참여하기 어렵기 때문에 재사용성이 저하된다
- 책임 주도 설계(Responsibility-Driven Design, RDD)는 협력이라는 문맥 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다

## 은유와 객체

의인화
- 현실 속 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 땐 능동적으로 변한다는 것이다
- 소프트웨어 객체를 창조할 때 결코 현실 세계의 객체를 모방하지 않는다
	- 오히려 소프트웨어 안에 창조하는 객체에게 현실 세계의 객체와는 전혀 다른 특징을 부여함
- 레베카 워프스브록은 현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화(anthropomorphism)라고 부른다

은유
- 현실 세계와 객체지향 세계 사이의 관계를 좀 더 정확하게 설명할 수 있는 단어는 은유(metaphor)다
- 현실 속의 객체의 의미 일부가 소프트웨어 객체로 전달되기 때문에 프로그램 내의 객체는 현실 속의 객체에 대한 은유다
- 은유는 표현적 차이(representational gap)또는 의미적 차이(semantic gap)라는 논점과 관련성이 깊다
	- 여기서 차이란 소프트웨어에 대해 사람들이 생각하는 모습과 실제 소프트웨어의 표현 사이의 차이를 의미한다
	- 은유 관계에 있는 실제 객체의 이름을 소프트웨어 객체의 이름으로 사용하면 표현적 파이를 줄여 소프트웨어의 구조를 쉽게 예측할 수 있다
	- 따라 소프트웨어 객체에 대한 현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다