## Topic 08. 좋은 설계의 핵심

`좋은 설계는 나쁜 설계보다 바꾸기 쉽다`
- ETC(easier to change) 원칙을 따르자
	- 왜 결합도를 줄이면 좋은가? → 각각이 더 바뀌기 쉽기 때문에
	- 왜 단일 책임 원칙(single responsiblity principle)이 유용한가? → 요구사항이 바뀌더라도 모듈 하나만 바꿔서 반영할 수 있기 때문에
	- 왜 이름 짓기가 중요한가? → 이름이 좋으면 코드가 읽기 쉬워지고 코드를 바꾸러면 코드를 읽어야 함

`ETC는 규칙이 아니라 가치`
- 가치 → 우리가 결정을 내리게 도움을 주는 것
- 가치의 내면화 → 내가 한 일이 전체 시스템을 바꾸기 쉽게 만들었을까 스스로 질문 
- 앞으로 어떤 모습으로 바뀔지 잘 모르겠을 때  <바꾸기 쉽게> 라는 길을 선택하기
	- 교체 가능하게 작성 = 결합도를 낮추고 응집도를 높이자
- 직관을 발전시키는 기회로 삼기 → 변경 사항에 대한 추측을 정리하자

## Topic 09. DRY: 중복의 해악 (Don’t Repeat Yourself)

`모든 코드 중복이 지식의 중복은 아니다`
- 코드는 동일하지만 두 함수가 표현하는 지식이 다를 수 있다

`문서화 중복`
- 함수의 의도가 주석으로, 코드로 두 번 표현되는 경우
- 주석이 코드에 어떤 가치를 더하는지 생각해 볼 것

## Topic 10. 직교성

`직교성(orthogonality)`
- 설계와 빌드, 테스트, 확장이 쉬운 시스템을 만드는 데에 있어 매우 중요한 개념
- 일종의 독립성이나, 결합도 줄이기(decoupling)를 의미
	- 하나가 바뀌어도 나머지에 어던 영향도 주지 않으면 직교한다고 할 수 있음

`직교성의 장점`
- 생산성 향상
	- 변화를 국소화해서 개발 시간과 테스트 시간이 줄어든다
	- 직교적인 접근법은 재사용도 촉진한다
	- 직교적인 컴포넌트들을 결합하는 경우얻을 수 있는 꽤 미묘한 생산성 향상 요소가 있다
		- A 컴포넌트가 M가지 일, B 컴포넌트가 N가지 일을 할 수 있으면 둘을 결합했을 땐 M x N 개의 일을 할 수 있다. 비-직교적인 관계라면 할 수 있는 일의 가지수가 줄어들게 된다.
- 리스크 감소
	- 감염된 코드가 격리되어 있다
	- 시스템이 잘 깨지지 않는다
	- 직교적인 시스템은 그 안의 컴포넌트들에 대해 테스트를 설계하고 실행하기 훨씬 쉽다
	- 특정 업체나 제품, 플랫폼에 덜 종속적이다

`설계`
- 시스템은 서로 협력하는 모듈의 집합으로 구성되어야 하고, 각 모듈은 다른 부분과 독립적인 기능을 구현
- 컴포넌트들이 계층으로 묶여서 계층 단위의 추상화를 제공하기도 함
	- 계층 구조는 직교적 시스템을 설계하는 강력한 방법
		- 각 계층은 자기 바로 밑에 있는 계층이 제공하는 추상화만을 사용하기 때문에, 다른 코드에 영향을 끼치지 않으면서 기반 구현들을 변경할 수 있게 됨
		- 사용자 인터페이스 → 데이터 베이스 접근 / 권한 부여 / 비즈니스 로직 → 애플리케이션 프레임워크 (표준 라이브러리) / 컨테이너 서비스

`코딩`
- 코드의 결합도를 줄여라
	- 불필요한 것은 다른 모듈에 보여주지 않고, 다른 모듈의 구현에 의존하지 않는 코드를 작성하라
	- 객체의 상태를 바꿀 필요가 있다면 객체가 직접 상태를 바꿀 수 있도록 해야 함
- 전역 데이터를 피하라
	- 글로벌 데이터를 참조할 때마다 코드는 해당 데이터를 공유하는 다른 컴포넌트와 묶이게 된다
	- 읽기 전용이라도 문제가 생길 수 있다
	- 싱글턴은 불필요한 결합을 만들 수 있다
- 유사한 함수를 피하라
	- 전략 패턴을 통해 더 낫게 구현할 순 없는지 고민하자

`테스트`
- 단위 테스트를 작성하는 행위 자체가 직교성을 테스트해 볼 수 있는 기회다
- 버그 수정은 시스템의 직교성을 총체적으로 점검해 볼 수 있는 값진 시간이다

`문서화`
- 문서를 내용과 표현 두 가지 관점에서 바라보자
- 직교적인 문서라면 내용 변화 없이 모양새를 바꿀 수 있다

## Topic 11. 가역성

`유연한 아키텍처`
- 우리가 할 수 있는 것은 바꾸기 쉽게 만드는 것
- 외부의 API를 우리가 만든 추상화 계층 뒤에 숨기자

## Topic 12. 예광탄

`목표물을 찾기 위해 예광탄을 써라`
- 우리의 요구사항으로부터 최종 시스템의 일부 측면까지 빨리, 눈에 보이게, 도달하게 해 줄 무언가를 찾아야 함
- 간단한 기능을 골라 여러 계층을 통합해 봐야 한다

`예광탄 코드 접근 방법의 장점`
- 사용자가 뭔가 작동하는 것을 일찍부터 보게 된다
- 개발자가 들어가서 일할 수 있는 구조를 얻는다
- 통합 작업을 수행할 기반이 생긴다
- 보여줄 것이 생긴다
- 진행 상황에 대해 더 정확하게 감을 잡을 수 있다

## Topic 13. 프로토타입과 포스트잇

`프로토타이핑 대상`
- 아키텍처
- 기존 시스템에 추가할 새로운 기능
- 외부 데이터의 구조 혹은 내용
- 외부에서 가져온 도구나 컴포넌트
- 성능 문제
- 사용자 인터페이스 설계

`프로토타입을 어떻게 사요할 것인가`
- 정확성: 적절이 더미 데이터를 사용할 수 있다
- 완전성: 제한된 방식으로만 작동하기도 한다
- 안정성: 오류 검사를 빼먹거나 아예 무시할 수 있다
- 스타일: 프로토타입 자체에는 주석이나 문서가 많지 않아야 한다. 하지만 프로토타입을 사용한 결과를 문서로 많이 작성할 수는 있다

## Topic 14. 도메인 언어

## Topic 15. 
